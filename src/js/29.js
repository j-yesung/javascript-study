// 카운트 상태 변경 함수 #1
// 함수가 호출될 때마다 호출된 횟수를 누적하여 출력하는 카운터를 구현해요!

// 카운트 상태 변수
// let num = 0;

// 카운트 상태 변경 함수
// const increase = function () {
//   // 카운트 상태를 1만큼 증가시킨다.
//   return ++num;
// };

// console.log(increase());
// // num = 100; // 치명적인 단점이 있어요.
// console.log(increase());
// console.log(increase());

/**
 * 보완해야 할 사항
 * 카운트 상태(num 변수의 값)는 increase 함수가 호출되기 전까지 변경되지 않고 유지돼야 한다.
 * 이를 위해 카운트 상태(num 변수의 값)는 increase 함수만이 변경할 수 있어야 한다.
 * 전역변수인 num이 문제다 -> 지역변수로 바꿔볼까?
 */
// 카운트 상태 변경 함수 #2
// const increase = function () {
//   // 카운트 상태 변수
//   let num = 0;

//   // 카운트 상태를 1만큼 증가시킨다.
//   return ++num;
// };

// // 이전 상태값을 유지 못함
// console.log(increase()); //1
// console.log(increase()); //1
// console.log(increase()); //1
/**
 * [리뷰]
 * num 변수는 increase 함수의 지역변수로 선언됐기 때문에 의도치 않는 변경은 방지됐음!
 * 즉, num 변수의 상태는 increase 함수만이 변경할 수 있다.
 * 하지만, increase()가 호출될 때마다 num이 초기화 😅
 * 백번, 천번 호출해도 언제 1인 increase...
 * 의도치 않은 변경은 방지하면서, 이전 상태를 유지해야 함!
 * 클로저를 사용해보자!
 */
/*
[코드 설명]
- 위 코드가 실행되면 즉시 실행 함수가 호출되고 즉시 실행 함수가 반환한 함수가 increase 변수에 할당된다.
- increase 변수에 할당된 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저다
- 즉시 실행 함수는 호출된 이후 소멸되지만, 즉시 실행 함수가 반환한 클로저는 increase 변수에 할당되어 호출된다.
- 이때 즉시 실행 함수가 반환한 클로저는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하고 있다.
- 따라서 즉시 실행 함수가 반환한 클로저는 카운트 상태를 유지하기 위한 자유 변수 num을 언제 어디서 호출하든지 참조하고 변경할 수 있다.
- num은 초기화되지 않을 것이며, 외부에서 직접 접근할 수 없는 은닉된 private 변수이므로, 전역 변수를 사용했을 때와 같이 의도되지 않은 변경을 걱정할 필요도 없다.
*/
// 카운트 상태 변경 함수 #3
const increase = (function () {
  // 카운트 상태 변수
  let num = 0;

  // 클로저
  return function () {
    return ++num;
  };
})();

// 이전 상태값을 유지
console.log(increase()); //1
console.log(increase()); //2
console.log(increase()); //3
